using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/********************************************************************************/
/* Steadsoft.Spitfire v1.0.0.0                                                  */
/* Warning DO NOT MODIFY this struct by editing.                                */
/* This code was generated by a software tool.                                  */
/********************************************************************************/

namespace Steadsoft.Spitfire.STM32MP153.Peripherals
{
    public partial class Gpio
    {
        public ref Registers.MODER MODER => ref GetAsRegister<Registers.MODER>(0x0000);
        public ref Registers.OTYPER OTYPER => ref GetAsRegister<Registers.OTYPER>(0x0004);
        public ref Registers.OSPEEDR OSPEEDR => ref GetAsRegister<Registers.OSPEEDR>(0x0008);
        public ref Registers.PUPDR PUPDR => ref GetAsRegister<Registers.PUPDR>(0x000C);
        public ref Registers.ODR ODR => ref GetAsRegister<Registers.ODR>(0x0014);
        public ref Registers.BSRR BSRR => ref GetAsRegister<Registers.BSRR>(0x0018);
        public ref Registers.LCKR LCKR => ref GetAsRegister<Registers.LCKR>(0x001C);
        public ref Registers.AFRL AFRL => ref GetAsRegister<Registers.AFRL>(0x0020);
        public ref Registers.AFRH AFRH => ref GetAsRegister<Registers.AFRH>(0x0024);
        public ref Registers.BRR BRR => ref GetAsRegister<Registers.BRR>(0x0028);

        public static class Registers
        {
            public struct MODER : IRegister
            {
                private uint allBits;

                private MODER(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits; set => allBits = value; }

                public Mode this[int B]
                {
                    get => (Mode)GetAsBitVector32(ref allBits)[BitSupport.VectorOf2Bits[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf2Bits[CheckMax(B, 15)]] = (int)value;
                }

                public static implicit operator uint (MODER R) => R.allBits;
                public static implicit operator MODER(uint R) => new MODER(R);
            }

            public struct OTYPER : IRegister
            {
                private uint allBits;

                private OTYPER(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits & 0x0000FFFFU; set => allBits = value & 0x0000FFFFU; }

                public bool this[int B]
                {
                    get => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]] = value;
                }

                public static implicit operator uint (OTYPER R) => R.allBits;
                public static implicit operator OTYPER(uint R) => new OTYPER(R);
            }

            public struct OSPEEDR : IRegister
            {
                private uint allBits;

                private OSPEEDR(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits; set => allBits = value; }

                public Speed this[int B]
                {
                    get => (Speed)GetAsBitVector32(ref allBits)[BitSupport.VectorOf2Bits[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf2Bits[CheckMax(B, 15)]] = (int)value;
                }

                public static implicit operator uint (OSPEEDR R) => R.allBits;
                public static implicit operator OSPEEDR(uint R) => new OSPEEDR(R);
            }

            public struct PUPDR : IRegister
            {
                private uint allBits;

                private PUPDR(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits; set => allBits = value; }

                public Pull this[int B]
                {
                    get => (Pull)GetAsBitVector32(ref allBits)[BitSupport.VectorOf2Bits[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf2Bits[CheckMax(B, 15)]] = (int)value;
                }

                public static implicit operator uint (PUPDR R) => R.allBits;
                public static implicit operator PUPDR(uint R) => new PUPDR(R);
            }

            public struct ODR : IRegister
            {
                private uint allBits;

                private ODR(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits & 0x0000FFFFU; set => allBits = value & 0x0000FFFFU; }

                public bool this[int B]
                {
                    get => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]] = value;
                }

                public static implicit operator uint (ODR R) => R.allBits;
                public static implicit operator ODR(uint R) => new ODR(R);
            }

            public struct BSRR : IRegister
            {
                private uint allBits;

                private BSRR(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits; set => allBits = value; }

                public bool this[int B]
                {
                    get => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 31)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 31)]] = value;
                }

                public static implicit operator uint (BSRR R) => R.allBits;
                public static implicit operator BSRR(uint R) => new BSRR(R);
            }

            public struct LCKR : IRegister
            {
                private uint allBits;

                private LCKR(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits & 0x0000FFFFU; set => allBits = value & 0x0000FFFFU; }

                public bool this[int B]
                {
                    get => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]] = value;
                }

                public static implicit operator uint (LCKR R) => R.allBits;
                public static implicit operator LCKR(uint R) => new LCKR(R);
            }

            public struct AFRL : IRegister
            {
                private uint allBits;

                private AFRL(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits; set => allBits = value; }

                public AlternateFunction this[int B]
                {
                    get => (AlternateFunction)GetAsBitVector32(ref allBits)[BitSupport.VectorOf4Bits[CheckMax(B, 7)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf4Bits[CheckMax(B, 7)]] = (int)value;
                }

                public static implicit operator uint (AFRL R) => R.allBits;
                public static implicit operator AFRL(uint R) => new AFRL(R);
            }

            public struct AFRH : IRegister
            {
                private uint allBits;

                private AFRH(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits; set => allBits = value; }

                public AlternateFunction this[int B]
                {
                    get => (AlternateFunction)GetAsBitVector32(ref allBits)[BitSupport.VectorOf4Bits[CheckMax(B, 7)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf4Bits[CheckMax(B, 7)]] = (int)value;
                }

                public static implicit operator uint (AFRH R) => R.allBits;
                public static implicit operator AFRH(uint R) => new AFRH(R);
            }

            public struct BRR : IRegister
            {
                private uint allBits;

                private BRR(uint Initial)
                {
                    allBits = Initial;
                }

                public uint AllBits { get => allBits & 0x0000FFFFU; set => allBits = value & 0x0000FFFFU; }

                public bool this[int B]
                {
                    get => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]];
                    set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax(B, 15)]] = value;
                }

                public static implicit operator uint (BRR R) => R.allBits;
                public static implicit operator BRR(uint R) => new BRR(R);
            }

            }
    }
}
