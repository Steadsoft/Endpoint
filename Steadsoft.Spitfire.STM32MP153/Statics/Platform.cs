using Microsoft.VisualBasic;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using UnitsNet;

namespace Steadsoft.Spitfire.STM32MP153
{
    public static class Platform
    {
        public static void WithoutGC(int TotalSize, Action Action)
        {
            if (GC.TryStartNoGCRegion(TotalSize))    // allows 
            {
                try
                {
                    Action();
                }
                finally
                {
                    if (GCSettings.LatencyMode == GCLatencyMode.NoGCRegion)
                        GC.EndNoGCRegion();
                }
            }
        }

        public static void WithoutGC<T>(int TotalSize, Action<T> Action, T Argument)
        {
            if (GC.TryStartNoGCRegion(4096))    // allows 
            {
                try
                {
                    Action(Argument);
                }
                finally
                {
                    if (GCSettings.LatencyMode == GCLatencyMode.NoGCRegion)
                        GC.EndNoGCRegion();
                }
            }
        }
    }


    public static class Generator
    {
        public static string GeneratePeripheralClass(string PeripheralName, string Folder, string Filename, int Indent = 0, string Namespace = null, bool Timestamp = false)
        {
            ArgumentNullException.ThrowIfNullOrWhiteSpace(PeripheralName, nameof(PeripheralName));
            ArgumentNullException.ThrowIfNullOrWhiteSpace(Folder, nameof(Folder));
            ArgumentNullException.ThrowIfNullOrWhiteSpace(Filename, nameof(Filename));

            return GeneratePeripheralClass(PeripheralName, File.ReadAllLines(Folder + Filename), Indent, Namespace, Timestamp);
        }
        public static string GeneratePeripheralClass(string PeripheralName, IEnumerable<string> Regdefs, int Indent = 0, string Namespace = null, bool Timestamp = false)
        {
            ArgumentNullException.ThrowIfNullOrWhiteSpace(PeripheralName, nameof(PeripheralName));
            Regdefs.ThrowIfSeqNullOrEmpty("The register defintions must not be empty.");

            var assembly = Assembly.GetExecutingAssembly();
            var assemblyVersion = assembly.GetName().Version;

            List<string> regstructs = new List<string>();
            List<(string, uint)> regDetails = new List<(string, uint)>();

            var cleaned = Regdefs.Where(r => (r.TrimStart().StartsWith("//") == false) && r.Trim() != String.Empty);

            foreach (string Regdef in cleaned)
            {
                var reg = GenerateRegisterStruct(0, Regdef, true, out var regname, out var offset);

                regstructs.Add(reg);
                regDetails.Add((regname, offset));
            }

            IndentingBuilder builder = new IndentingBuilder();

            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using System.Linq;");
            builder.AppendLine("using System.Text;");
            builder.AppendLine("using System.Threading.Tasks;");
            builder.AppendLine();

            builder.AppendLine("/".PadRight(80, '*') + "*/");
            builder.AppendLine($"/* Steadsoft.Spitfire v{assemblyVersion}".PadRight(80, ' ') + "*/");
            builder.AppendLine("/* Warning DO NOT MODIFY this struct by editing.".PadRight(80, ' ') + "*/");

            if (Timestamp)
                builder.AppendLine($"/* This code was generated by a software tool on {DateAndTime.DateString} at {DateAndTime.TimeString}.".PadRight(80, ' ') + "*/");
            else
                builder.AppendLine($"/* This code was generated by a software tool.".PadRight(80, ' ') + "*/");

            builder.AppendLine("/".PadRight(80, '*') + "*/");
            builder.AppendLine();

            if (Namespace != null)
            {
                builder.AppendLine($"namespace {Namespace}");
                builder.AppendLine("{", 4);
            }

            builder.AppendLine($"public partial class {PeripheralName}");
            builder.AppendLine("{", 4);

            foreach (var detail in regDetails)
            {
                string regname = detail.Item1;
                uint offset = detail.Item2;

                builder.AppendLine($"public ref Registers.{regname} {regname} => ref GetAsRegister<Registers.{regname}>(0x{offset:X4});");
            }

            builder.AppendLine();

            builder.AppendLine("public static class Registers");
            builder.AppendLine("{", 4);

            foreach (string desc in cleaned)
            {
                builder.AppendLine(GenerateRegisterStruct(builder.Indentation, desc, true, out _, out _));
            }

            builder.AppendLine("}", -4);

            builder.AppendLine(-4, "}");

            if (Namespace != null)
            {
                builder.AppendLine(-4, "}");
            }

            return builder.ToString();

        }

        public static string GenerateRegisterStruct(int Indent, string Descriptor, bool Uppercase, out string Regname, out uint Regoffset)
        {

            var reg = RegisterDescriptor.Create(Descriptor, Uppercase);

            Regname = reg.RegisterName;
            Regoffset = reg.RegisterOffset;

            IndentingBuilder builder = new IndentingBuilder();


            builder.AppendLine($"public struct {reg.RegisterName} : IRegister");
            builder.Increase(Indent);
            builder.AppendLine("{");
            builder.Increase(4);

            builder.AppendLine("private uint allBits;");
            builder.AppendLine();
            builder.AppendLine($"private {reg.RegisterName}(uint Initial)");
            builder.AppendLine("{", 4);
            builder.AppendLine("allBits = Initial;");
            builder.AppendLine(-4, "}");
            builder.AppendLine();

            if (reg.UnusedBits.Data == 0)
            {
                builder.AppendLine($"public uint AllBits {{ get => allBits; set => allBits = value; }}");
            }
            else
            {
                builder.AppendLine($"public uint AllBits {{ get => allBits & 0x{reg.UsedBits.Data:X8}U; set => allBits = value & 0x{reg.UsedBits.Data:X8}U; }}");
            }

            builder.AppendLine();

            foreach (var field in reg.Fields)
            {
                string typetext_get;
                string typetext_set;
                string subscript;

                if (field.Type == "bool")
                {
                    typetext_get = "Convert.ToBoolean";
                    typetext_set = "Convert.ToUInt32";
                }
                else
                {
                    typetext_get = $"({field.Type})";
                    typetext_set = "Convert.ToUInt32";
                }

                if (field.Thistype == "int")
                {
                    subscript = "B"; 
                }
                else
                {
                    subscript = "Convert.ToInt32(B)";
                }

                if (field.Isthis)
                {
                    if (field.Type == "bool")
                    {
                        builder.AppendLine($"public {field.Type} this[{field.Thistype} B]");
                        builder.AppendLine("{", 4);



                        builder.AppendLine($"get => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax({subscript}, {field.Fragments[0].Item1 - 1})]];");
                        builder.AppendLine($"set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf1Bit[CheckMax({subscript}, {field.Fragments[0].Item1 - 1})]] = value;");
                        builder.AppendLine(-4, "}");
                    }
                    else
                    {
                        builder.AppendLine($"public {field.Type} this[{field.Thistype} B]");
                        builder.AppendLine("{", 4);
                        builder.AppendLine($"get => ({field.Type})GetAsBitVector32(ref allBits)[BitSupport.VectorOf{field.Fragments[0].Item2}Bits[CheckMax({subscript}, {field.Fragments[0].Item1 - 1})]];");
                        builder.AppendLine($"set => GetAsBitVector32(ref allBits)[BitSupport.VectorOf{field.Fragments[0].Item2}Bits[CheckMax({subscript}, {field.Fragments[0].Item1 - 1})]] = (int)value;");
                        builder.AppendLine(-4, "}");
                    }
                }
                else
                {
                    builder.AppendLine($"public {field.Type} {field.Name}");
                    builder.AppendLine("{", 4);

                    if (field.ShiftAndPairs.Length == 1)
                    {
                        builder.AppendLine($"get => {typetext_get} ((this {GetRightShiftText(field.ShiftAndPairs[0].Item2)} & 0x{field.ShiftAndPairs[0].Item1:X8}U)) ;");
                        builder.AppendLine($"set => AllBits = (this & 0x{field.NotMask:X8}U) | (({typetext_set}(value) & 0x{field.ShiftAndPairs[0].Item1:X8}U){GetLeftShiftText(field.ShiftAndPairs[0].Item2)});");
                    }
                    else
                    {
                        builder.AppendLine($"get => {typetext_get} ((this {GetRightShiftText(field.ShiftAndPairs[0].Item2)} & 0x{field.ShiftAndPairs[0].Item1:X8}U) | (this >> {field.ShiftAndPairs[1].Item2} & 0x{field.ShiftAndPairs[1].Item1:X8}U)  ) ;");
                        builder.AppendLine($"set => AllBits = (this & 0x{field.NotMask:X8}U) | (({typetext_set}(value) & 0x{field.ShiftAndPairs[0].Item1:X8}U){GetLeftShiftText(field.ShiftAndPairs[0].Item2)}) | (({typetext_set}(value) & 0x{field.ShiftAndPairs[1].Item1:X8}U){GetLeftShiftText(field.ShiftAndPairs[1].Item2)});");
                    }

                    builder.AppendLine(-4, "}");
                    builder.AppendLine();
                }
            }

            builder.AppendLine();
            builder.AppendLine($"public static implicit operator uint ({reg.RegisterName} R) => R.allBits;");
            builder.AppendLine($"public static implicit operator {reg.RegisterName}(uint R) => new {reg.RegisterName}(R);");


            builder.AppendLine(-4, "}");
            return builder.ToString();
        }

        public static string GetLeftShiftText(uint shift)
        {
            if (shift == 0)
                return "";

            return $" << {shift}";
        }

        public static string GetRightShiftText(uint shift)
        {
            if (shift == 0)
                return "";

            return $" >> {shift}";
        }
    }

    public class RegisterDescriptor
    {
        private string registerName;
        private string descriptorText;
        private List<FieldDescriptor> fields = new List<FieldDescriptor>();
        private BitVector32 usedBits = new BitVector32();
        private uint registerOffset;
        private RegisterDescriptor(string RegisterName, uint RegisterOffset, string RegisterText, List<FieldDescriptor> Descriptors)
        {
            registerName = RegisterName;
            registerOffset = RegisterOffset;
            descriptorText = RegisterText;
            fields = Descriptors;

            foreach (FieldDescriptor field in fields)
            {
                if (field.Isthis)
                {
                    var (elements, length) = field.Fragments[0];

                    var total_bits = elements * length;

                    for (int W = 0; W < total_bits; W++)
                    {
                        usedBits[BitSupport.VectorOf1Bit[W]] = true;
                    }
                }
                else
                {
                    foreach (var pair in field.Fragments)
                    {
                        for (int K = 0; K < pair.Item2; K++)
                        {
                            usedBits[BitSupport.VectorOf1Bit[pair.Item1 - K]] = true;
                        }
                    }

                }
            }
        }

        public string RegisterName { get => registerName; }
        public List<FieldDescriptor> Fields { get => fields; }
        public string DescriptorText { get => descriptorText; }
        public BitVector32 UsedBits { get => usedBits; }
        public BitVector32 UnusedBits { get => new BitVector32(~(UsedBits.Data)); }
        public uint RegisterOffset { get => registerOffset; set => registerOffset = value; }

        public static RegisterDescriptor Create(string DescriptorText, bool UppercaseNames)
        {
            if (string.IsNullOrWhiteSpace(DescriptorText))
            {
                throw new ArgumentException($"'{nameof(DescriptorText)}' cannot be null or whitespace.", nameof(DescriptorText));
            }

            var fields = ParseDescriptor(DescriptorText, UppercaseNames, out var RegisterName, out uint RegisterOffset);

            return new RegisterDescriptor(RegisterName, RegisterOffset, DescriptorText, fields);
        }

        public static List<FieldDescriptor> ParseDescriptor(string Text, bool UppercaseNames, out string RegisterName, out uint RegisterOffset)
        {
            var cleaned = Text.Replace(" ", "").Replace(Environment.NewLine, "");

            if (Regex.IsMatch(cleaned, Constants.Syntax) == false)
                throw new ArgumentException();

            var textFields = cleaned.Split(':', ';').Where(f => f != "").ToArray();

            var prefix = UppercaseNames ? textFields[0].ToUpper() : textFields[0];

            var prefixParts = prefix.Split('(', ')');

            RegisterName = prefixParts[0];

            RegisterOffset = Convert.ToUInt32(prefixParts[1], 16);

            List<FieldDescriptor> result = new List<FieldDescriptor>();

            foreach (var field in textFields.Skip(1))
            {
                if (field.StartsWith("this."))
                {
                    var parts = field.Split('(', ',', ')', '.');

                    var thistype = parts[1];
                    var elements = Convert.ToInt32(parts[2]);
                    var len = Convert.ToInt32(parts[3]);

                    result.Add(new FieldDescriptor("this", parts[4], [(elements, len)], thistype));
                }
                else
                if (field.StartsWith("this"))
                {
                    var parts = field.Split('(', ',', ')');

                    var elements = Convert.ToInt32(parts[1]);
                    var len = Convert.ToInt32(parts[2]);

                    result.Add(new FieldDescriptor("this", parts[3], [(elements, len)]));
                }
                else
                {
                    var parts = field.Split('(', ')');
                    var pairs = new List<(int, int)>(); ;

                    if (parts.Length != 3)
                        throw new ArgumentException($"The field '{field}' is invalidly formed.", nameof(Text));

                    var fname = UppercaseNames ? parts[0].ToUpper() : parts[0];
                    var ftype = parts[2];

                    var digits = parts[1].Split(',');

                    if (digits.Length % 2 != 0)
                        throw new ArgumentException($"The field '{field}' has an invalid defintion.", nameof(Text));

                    for (int I = 0; I < digits.Length; I += 2)
                    {
                        var (bitpos, bitlen) = (Convert.ToInt32(digits[I]), Convert.ToInt32(digits[I + 1]));
                        pairs.Add((bitpos, bitlen));
                    }

                    result.Add(new FieldDescriptor(fname, ftype, pairs));
                }
            }

            return result;
        }
    }

    public class FieldDescriptor
    {
        private (int, int)[] fragments;
        private string name;
        private string type;
        private bool isthis;
        private string thistype;
        public FieldDescriptor(string Name, string Type, List<(int, int)> Fragments, string ThisType = "int")
        {
            name = Name;
            type = Type;

            Fragments.Reverse();

            fragments = Fragments.ToArray();

            isthis = Name == "this";
            thistype = ThisType;
        }



        private IEnumerable<(uint, uint)> Shands
        {
            get
            {
                int offset = 0;

                foreach (var fragment in fragments)
                {
                    var (msb, len) = fragment;

                    var and = GenGetAnd(msb, len, offset);
                    var shft = GenGetShift(msb, len, offset);

                    yield return (and, shft);

                    offset = len;
                }
            }
        }

        public (uint, uint)[] ShiftAndPairs
        {
            get { return Shands.Reverse().ToArray(); }
        }

        public uint NotMask
        {
            get
            {
                unchecked
                {
                    var vector = new BitVector32((int)0xFFFFFFFF);

                    foreach (var fragment in fragments)
                    {
                        var (msb, len) = fragment;

                        for (int B = (msb - len) + 1; B <= (msb); B++)
                        {
                            vector[VectorOf1Bit[B]] = false;
                        }
                    }

                    return (uint)vector.Data;
                }
            }
        }

        public string Name { get => name; }
        public string Type { get => type; }
        public (int, int)[] Fragments { get => fragments; }
        public bool Isthis { get => isthis; }
        public string Thistype { get => thistype; }

        private uint GenGetAnd(int MSB, int Len, int Offset)
        {
            var vector = new BitVector32(0);

            MSB = (Len + Offset) - 1;

            for (var B = 0; B < Len; B++)
            {
                vector[VectorOf1Bit[MSB - B]] = true;
            }

            return (uint)vector.Data;
        }

        private uint GenGetShift(int MSB, int Len, int Offset)
        {
            return (uint)(MSB - (Len + Offset) + 1);
        }

        public override string ToString()
        {
            return Name;
        }
    }

    public class IndentingBuilder
    {
        private StringBuilder builder;
        private int indentation = 0;

        public int Indentation { get => indentation; }

        public IndentingBuilder()
        {
            builder = new StringBuilder();
        }

        public void Increase(int Spaces)
        {
            indentation += Spaces;
        }

        public void Decrease(int Spaces)
        {
            indentation -= Spaces;
        }

        public StringBuilder AppendLine()
        {
            return builder.AppendLine();
        }

        public StringBuilder AppendLine(string Text, int Indent)
        {
            var line = AppendLine(Text);
            Increase(Indent);
            return line;
        }

        public StringBuilder AppendLine(int Indent, string Text)
        {
            Increase(Indent);
            var line = AppendLine(Text);
            return line;
        }


        public StringBuilder AppendLine(string Text)
        {
            if (indentation > 0)
                return builder.AppendLine(Text.PadLeft(Text.Length + indentation));
            return builder.AppendLine(Text);
        }

        public override string ToString()
        {
            return builder.ToString();
        }
    }
}